package Day31_Threads.demo319;
/*
线程的生命周期：
新建：（创建线程对象）：start（）->就绪（有执行资格，没有执行权），抢到CPU执行权->运行
（有执行资格与执行权，java中没有定义运行这种状态，这里是为了更好理解，抢夺到执行权之后交给操作系统不管了）
停止一个线程运行的情况：
1.一旦被其他线程抢走执行权->又会回到就绪状态
2.一旦执行sleep（）方法->就会变成计时等待状态，没有执行资格与执行权，停止计时等待状态之后->就绪状态，故睡眠状态结束之后还需要抢执行权
3.一旦执行wait()方法就变成等待状态，别的线程执行notify方法能变成就绪状态
4.一旦无法获取锁就会编程阻塞状态，获得锁编程就绪状态
5.run（）方法执行完毕-> 死亡状态

线程的安全问题：执行下面的代码（3个窗口卖同100张票），可能会有问题：重复票号
线程1在执行完ticket++ 之后，没来得及执行输出语句，就被线程2，3执行了ticket++：导致他们都有可能输出同一个票号
该如何解决呢？
给共享数据的那一块代码锁起来，一次只能让一个线程进去
*/
public class Demo319 {
    public static void main(String[] args) {
        MyThread t0 = new MyThread();
        MyThread t1 = new MyThread();
        MyThread t2 = new MyThread();
        t0.start();
        t1.start();
        t2.start();
    }
}

